### 怎么理解协程？
协程是比线程更轻量级的执行单元：
- 线程： 由操作系统调度，切换开销大；
- 协程： 用户态调度，切换开销小，不需要系统调用；
- 优点： 资源消耗小、调度快、适合高并发场景。
- Go 中的 goroutine 就是一种协程，它通过 GMP 模型调度，能轻松实现成千上万个并发任务。

### Golang是怎么做上下文切换的
- 上下文切换是指 goroutine 在被挂起与恢复时，需要保存和恢复其执行状态（如栈指针、程序计数器、寄存器等）。
- P（Processor） 是调度核心，负责从本地队列中选择要运行的 goroutine，但 并不直接负责上下文的保存与恢复。
- 真正完成 上下文切换操作的是 Go runtime 调度器，通过底层的调度函数（如 gogo, gosave）来实现。
- 每个 G（goroutine） 结构中都保存了自己的上下文信息，切换时 runtime 会将当前 G 的上下文保存，并加载新的 G 的上下文，完成切换。

### 操作系统内核态是什么？
操作系统有两种运行态：
1. 用户态（User Mode）： 应用程序正常运行时的状态，不能直接访问硬件资源；
2. 内核态（Kernel Mode）： 操作系统核心代码运行的状态，拥有对系统资源的全部访问权限。
当程序需要执行特权操作（如IO、系统调用等）时，会发生从用户态到内核态的切换，这称为上下文切换。这通常伴随着性能开销。

### TCP 如何保证可靠和有序？
三次握手：保证连接建立的可靠性；
序列号+确认号（Sequence & ACK）：每个数据包都有序列号，接收方确认接收情况；
重传机制（ARQ）：如超时重传、快速重传；
滑动窗口：控制数据流，防止接收方来不及处理；
校验和：检测数据包在传输中是否被损坏；
拥塞控制：慢启动、拥塞避免、快速恢复、快速重传等算法，避免网络拥堵。

### 存储系统的了解
可从 KV 存储（如 RocksDB）、对象存储、分布式存储系统（如 HDFS）角度切入。

### 分布式系统了解？
把一个大的系统拆成多个节点协同工作，从而实现高性能、高可用和可扩展性。

| 组件 | 功能 |
|------|------|
| 服务注册中心（如 Consul、etcd、Nacos） | 管理各服务节点的注册与发现 |
| 负载均衡器（如 Nginx、LVS） | 把请求平均分配给多个后端节点 |
| 网关（如 Kong、APISIX） | 接入控制、路由转发、限流等 |
| 数据库/缓存（如 MySQL、Redis） | 存储数据、提升访问速度 |
| 消息队列（如 Kafka、RabbitMQ） | 解耦系统、异步通信 |
| 配置中心（如 Apollo） | 动态配置管理 |
| 日志与监控系统（如 ELK、Prometheus） | 采集、分析运行状态与故障 |


| 目标 | 说明 |
|------|------|
| 可扩展性（Scalability） | 支持服务的横向扩展，应对高并发访问 |
| 高可用性（Availability） | 某些节点故障时，系统依然能服务 |
| 容错性（Fault Tolerance） | 节点宕机、网络中断时系统能自我恢复 |
| 一致性（Consistency） | 多节点间数据保持一致性，特别重要 |
| 性能优化（Performance） | 并行处理，提高响应速度与吞吐量 |


### 告警系统
1. 分组变更如何处理？
- 把分组信息抽象为独立配置中心管理，支持热更新。
- 使用缓存降低查询成本，配置变动时做 TTL 缓存失效。

2. 频繁告警如何聚合？
- 设定时间窗口（如每 5 分钟）做聚合处理，可借助定时任务或流处理框架。
- 维度包括时间、类型、主机、分组等，使用 Redis/ES 作为聚合中间层。

3. 告警未恢复后如何“拉起来”？
设置告警生命周期状态，例如 PENDING -> ACTIVE -> RESOLVED。
如果超时未恢复，可主动检测状态，发出“持续告警”提醒。

4. 去重如何防止多节点重复发送？
可用消息队列（如 Kafka）统一发送，由消费端加锁/写入状态表去重。
每条告警设置唯一 ID，发送前先判断是否已发过。

5. 大规模请求下数据库压力如何应对？
使用缓存（如 Redis）做热点数据缓冲。
分库分表拆分读写压力。
实现限流机制（验证码、令牌桶、漏桶、固定窗口、滑动窗口）
请求排队（消息队列）

### TCP 为什么可靠？（多方面保证）
序号（Sequence Number）与确认号（ACK）
保证数据顺序和确认机制。

超时重传机制
数据未被确认则重传。

流量控制（Sliding Window）
防止发送方发太快压垮接收方。

拥塞控制
避免网络拥堵导致丢包。

三次握手
建立可靠连接，确保双方收发能力。

四次挥手
优雅断开连接，确保数据完整发送完。

- 拥塞控制
检测：超时重传、三次重复的ACK
解决：慢启动、拥塞避免、快重传、快恢复

### 如果 TCP 发送方发送太快，如何解决？
流量控制机制（基于窗口大小）
接收端通过 TCP 报文中的 窗口字段 告诉发送端自己可接受的数据量。
发送端根据这个窗口大小调整发送速率，避免数据丢失。

### 项目 | 进程 | 线程 | 协程
| - | 进程 | 线程 | 协程 |
|------|------|
| 定义 | 操作系统资源分配单位 | CPU调度的最小单位 | 用户态轻量级线程 |
| 开销 | 大（独立内存空间） | 中（共享内存，需切换） | 小（切换快，资源消耗低） |
| 通信 | 需进程间通信机制 | 可共享变量 | 同线程间天然共享 |
| 切换开销 | 高 | 中 | 低 |

### 并发场景下三者的优缺点
进程
优点：隔离性强，安全性好；缺点：开销大，通信复杂。
线程
优点：资源共享、上下文切换比进程快；缺点：资源争用问题、死锁风险。
协程
优点：极轻量、无需系统调用、切换快；缺点：不适合多核并行、易被阻塞

### 支持多进程的中间件/架构有哪些？
Nginx：主进程 + 多 worker 进程架构。

Redis：多进程用于持久化等功能。

RabbitMQ 等消息队列：可使用多进程处理消息。

### 同步和异步的区别
同步：调用者等待操作完成（阻塞）。

异步：调用后立即返回，操作完成后通知（不阻塞）。

### 异步是如何拿到结果的？
回调函数：完成任务后调用指定函数处理结果。