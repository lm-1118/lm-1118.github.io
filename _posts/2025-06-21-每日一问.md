### 1、已提交的状态是数据写到内存中还是写到磁盘中？
写到内存中并且日志（内存中）也写好了就是已提交，稍后会吧日志转到硬盘，在稍后就是数据到硬盘(具体的频率有三种情况)。

### 2、脏读，读的是新的数据还是旧的数据？
新的，但是是一个假的数据

### 3、为什么单级页表转换到多级页表可以节省空间？

### 4、为什么分页管理比分段管理减少了外部碎片？

### 5、硬链接不能跨越文件系统,软连接可以，这个文件系统指的是什么？

### 6、为什么哈希表取数据是常数级时间复杂度

### 7、细讲http1.0 1.1 2.0 3.0中的长连接、多路复用和队头堵塞的具体情况
- 1.0默认不支持长连接，会队头堵塞，无多路复用
- 1.1默认支持长连接，利用管道，请求不会堵塞，响应可能会堵塞，没有多路复用
- 2.0支持多路复用，多个流（stream）复用一个TCP，请求和回应都不会堵塞，但是TCP丢包影响全局
- 3.0基于QUIC连接，真正多路复用，每个http连接都是基于独立数据流

### 9、unordered_set、unordered_map、set、map的联系和区别
**底层实现**
set	    红黑树（自平衡二叉搜索树）
map	    红黑树（自平衡二叉搜索树）
unordered_set	哈希表
unordered_map	哈希表

 **时间复杂度**
| 操作   | `set` / `map`       | `unordered_set` / `unordered_map`     |
|--------|---------------------|---------------------------------------|
| **插入** | `O(log n)`          | **平均** `O(1)`，**最坏** `O(n)`       |
| **删除** | `O(log n)`          | **平均** `O(1)`，**最坏** `O(n)`       |
| **查找** | `O(log n)`          | **平均** `O(1)`，**最坏** `O(n)`       |
| **遍历** | **按升序遍历** `O(n)` | **无序遍历** `O(n)`                    |

### 10、
### 11、

