
---
title: 面经
date: 2025-06-21 10:00:00 +0800
categories: [面试经验, Go]
tags: [golang, 学习笔记, 面试相关]
---

### 04.07
有两场面试，一个是上海 ai lab（50/100），一个是上海一个小厂（80/100）
1. HTTP协议中的流式传输是用什么协议实现的
- 无论是传统的 HTTP 请求-响应，还是流式传输，本质上都是基于 TCP 这个传输层协议完成的数据传递。
- HTTP/2 流（stream）机制
HTTP/2 引入了多路复用，多个逻辑 stream 复用一个 TCP 连接，每个 stream 可独立传输。
底层依旧是 TCP，但数据以帧（frame）形式传输，更适合流式场景（比如 gRPC）。

2. 详细介绍一个aigc平台上传一个文件到返回用户信息整个过程和用到的中间件
用户上传的文件通过网关接入（鉴权JWT、限流、路由转发Trafik），先存入对象存储(一般都是用云存储)，通过消息队列异步(kafka、rabbitmq)通知AIGC服务（GPU节点）处理结果，处理后的结果存入Redis/MySQL，最后前端轮询或推送结果展示给用户。

3. 固定窗口之间的区别
- 固定窗口
将时间划分为一个个固定的区间（如每 1 秒一个窗口）。
每个窗口单独统计请求数量，达到阈值就拒绝后续请求。
- 滑动窗口
不是按固定时间段，而是按当前时间为参考点不断滑动窗口。每次请求的时候都检查时间点往前一段时间内的访问量。
将一个大窗口划分成多个小窗口（如 1 秒划分为 10 个 100ms 的小格），实时更新统计。
4. 防止缓存击穿是怎么实现的
- 把每一个请求抽象为一个Call，相同的key请求用map映射到同一个Call
- 第一个key请求，查询map没有，新建一个Call存入map，并且使用wg.Add(1)
- 剩余的同一个key的请求查询map有对应的Call，但是被wg.Wait()阻塞，直到第一个key的请求把数据库中的数据更新到缓存并且使用wg.Done()，然后剩余的请求才能拿到缓存中数据
- 生成新的Call和销毁一个Call的过程需要用Mutex加锁

5. 仿GroupCache的流程

```
Group.Get(key)
    ├── 本地缓存命中？ → 是 → 返回
    │
    └── 否 → load(key)
            ├── 找到远程节点→ 是本身吗？ 否 → getFromPeer → 成功返回
            │                          ↓ 是 → GetLocally
            └── getLocally
                  ├── 调用 Getter 拿原始数据
                  └── 缓存到 mainCache
            ↓
         返回结果
```

6. HTTP缓存的实现方式
- 每个网络端口抽象为一个peer（节点）
- 用三个网络端口开启三个进程，每个进程都有自己的mainCache和peers，这个peers里面就包括三个端口
- 假设第一个进程对应的端口中的mainCache没有缓存数据，就利用一致性哈希选择一个peer节点，然后向这个peer节点发送HTTP请求，这个peer节点对应的进程的mainCache中如果也没有，但是再利用一致性哈希只能找到自己所以就从SlowDB中加载到自己的mainCache并返回数据
- 下一次访问同一个key，还是第一个节点没有缓存数据，用一致性哈希选择节点，从那个节点的mainCache中取数据

7. Redis常见数据类型与使用
# Redis 数据类型与典型应用场景

| 数据类型       | 典型应用场景                                                                 |
|----------------|------------------------------------------------------------------------------|
| **String**      | - 缓存热点数据（用户 session、页面片段）<br>- 计数器（浏览量、自增 ID）<br>- 存储验证码、token、配置项 |
| **List**        | - 简易消息队列（任务推送、异步处理）<br>- 时间线/评论系统（按时间顺序）<br>- 日志系统收集 |
| **Hash**        | - 用户信息缓存（user:id -> name, email）<br>- 商品或文章详情结构化存储<br>- 用户购物车（商品 + 数量） |
| **Set**         | - 标签系统（如文章标签、兴趣分类）<br>- 社交系统好友/关注关系<br>- 签到、活跃用户去重 |
| **Sorted Set**  | - 排行榜系统（积分、热度）<br>- 内容推荐排序（点击量、活跃度）<br>- 延迟任务队列（score=时间戳） |
| **HyperLogLog** | - UV 统计（独立访客）<br>- 活动参与人数估算<br>- 大规模数据去重统计 |
| **Bitmap**      | - 用户签到记录（按天位标记）<br>- 是否看过某内容（位表示状态）<br>- 用户权限或在线状态标记 |
| **Stream**      | - 高级消息队列（支持 ack、持久化）<br>- 日志流系统<br>- 实时聊天、IoT 数据流 |

### 04-15
南京一个小厂（最快的一集，半小时不到）
1. goroutine底层，在golang中是什么地位。一个函数的多个G更倾向于分配到多个P还是一个P上（从全局队列拿G有没有什么倾向）
goroutine的底层本质 是一个非常轻量级的用户态线程，其核心是 Go 运行时（runtime）自己维护的调度系统。在底层实现中，goroutine 被表示为一个结构体 G，由 Go 的 GMP 模型管理和调度。
- goroutine的id
- 保存上下文：寄存器信息、程序计数器（PC）、栈指针（SP）等，支持协程切换。
- 状态管理：每个 G 都有状态，如 _Grunnable, _Gwaiting, _Grunning。

当前 P 是你创建 G 的“发起者”，直接放入它的本地队列效率最高，不需要加锁（相比全局队列需要锁），也避免了繁琐的上下文切换。
2. 以前的是GM现在是GMP，P起到什么作用 

| 功能项           | 说明                                                                 |
|------------------|----------------------------------------------------------------------|
| 本地 G 队列（runq） | 每个 P 拥有自己的 goroutine 队列，减少 G 的全局调度冲突。              |
| 调度上下文         | P 保存运行时的调度状态、分配的资源（比如内存、缓存等）。                 |
| M 和 G 的粘合剂     | M 只有在绑定 P 的情况下，才能执行 G。没有 P，M 无法调度。                 |
| 调度逻辑的载体      | Go 的调度循环 schedule() 是以 P 为中心进行的：找 G -> 找空闲 M -> 执行。 |
3. defer原理
📦 一、编译期原理
- 在 编译阶段，defer 并不是立即生成调用指令，而是将其作为一个特殊的结构记录下来，最终统一在函数返回前处理。
- 每个函数在编译时会有一个 defer 栈（链表）。
- 遇到 defer，会将其封装为一个结构体 deferproc，加入当前函数的 defer 链表中。
- 编译器在函数 return 前会插入一段代码，调用这些 defer 的函数。
🏃‍♂️ 二、运行期原理
- 在函数运行过程中：
- 执行到 defer 语句时：
- 会计算 defer 的函数参数值，并将函数指针 + 参数一起封装为一个结构体（称为 _defer）。
- 把这个 _defer 放入当前 goroutine 的 defer 链表中。
- 函数退出时（正常 return 或 panic）：会按**先进后出（LIFO）** 的顺序依次调用 _defer 链表中的函数。
4. HTTP和RPC区别
- HTTP是一个应用层协议，RPC是远程过程调用，只是一种函数（或方法）调用方式，与之对应的是本地调用，所谓的RPC协议其实只是基于TCP、UDP甚至是HTTP2改造之后的协议
- HTTP有很多适应浏览器的冗余字段，这些事内部服务用不到的，RPC可以摒弃很多HTTP Header中的字段（比如浏览器的各种行为）
- HTTP数据格式是JSON/XML（文本格式），但是RPC是Protobuf、Thrift（二进制格式），后者传输效率更高
- HTTP更适用于Web应用、前后端交互，而RPC更适用于微服务、分布式系内部通信。

RPC比HTTP出现的早，主要就是为了解决远程函数调用的问题。
一个单体服务内部的各个模块之间可以直接用本地函数（方法）调用，但是一个分布式微服务的系统内部各个模块的都是独立的服务，他们可能存储在不同的主机或者不同的容器中，那么他们就只能用远程函数（方法）调用
5. 介绍一下MYSQL的索引、索引失效？
- 索引是数据库中用于加速查询效率的一种数据结构，就像书本的目录，可以快速定位数据而不用全表扫描。
- 加速查询、范围扫描、排序
- 常见的有主键索引、唯一索引、普通索引、组合索引
- InnoDB默认使用b+树
- 注意建立索引的时机和索引的使用
- Explain查询是否命中索引
6. docker编写dockerfile流程，RUN命令写一行还是多行好
- 指定基础镜像（FROM）、设置环境变量（ENV）、安装依赖（RUN）拷贝文件（COPY、ADD）、运行命令（CMD）
- RUN：在镜像构建阶段执行命令，并将执行结果提交为新的一层镜像。

| 写法风格             | 优点                                           | 缺点                                                       |
|----------------------|------------------------------------------------|------------------------------------------------------------|
| 一行一个 RUN         | 清晰易读、便于调试                             | 每一条 RUN 会生成一个中间镜像层，最终镜像变大，构建变慢   |
| 多条命令合并一行 RUN | 减少镜像层数，镜像更小，构建更快               | 可读性差，调试困难，改动后容易导致缓存失效                 |

7. 僵尸进程是什么，wait()/waitpid()有什么用？原理是？
- 子进程已经退出，但其父进程尚未调用 wait 或 waitpid 回收它的退出状态信息，导致其在系统中仍占据一个进程表项的特殊进程。
- wait()	阻塞等待任意一个子进程结束，并回收它的资源。
- waitpid()	可以精确指定等待某个子进程结束；支持非阻塞模式，更灵活。
- 子进程执行完毕后调用 exit()，进入退出状态。内核不会立即释放该进程的 PCB（进程控制块），而是将其标记为 Z（僵尸进程），并记录其退出状态。内核给父进程发送 SIGCHLD 信号，通知它有子进程退出。
8. 一个表里面只有姓名、性别和年龄三个字段，怎么设置索引比较好

| 字段   | 是否建议建索引 | 理由                         |
|--------|----------------|------------------------------|
| name   | ✅ 是           | 查询常用字段，区分度高        |
| age    | ✅ 是           | 可用于范围查询               |
| gender | ❌ 否           | 只有两种值，区分度低，索引不生效 |
name和age也可以建立组合索引（注意顺序）
9. ceph的存储和使用，存大文件好还是小文件好，存静态文件好还是动态文件好
👉 RGW（前台）接收你上传的文件。
👉 RGW 把 example.txt 切成几个“页”大小的小块（对象）。
👉 RGW 查询 MON（管理员）：我要存这些小块，去哪放？
👉 MON 看当前 OSD 状态，结合 CRUSH 算法，告诉 RGW：
小块1 放 OSD3、OSD5、OSD7（副本）
小块2 放 OSD2、OSD4、OSD6
👉 RGW 把小块分别发到这些 OSD 存起来。
👉 RGW 在 omap 中记录：你这个 example.txt 是由哪几个小块组成的，每块的名字、大小等。
✅ 上传完成！

| 文件类型 | 是否适合使用 Ceph | 理由 |
|----------|-------------------|------|
| 大文件（如视频、备份镜像） | ✅ 适合 | 更容易划分为对象，元数据压力小，系统吞吐高 |
| 小文件（如图片、日志、文档） | ❌ 不太适合（除非优化） | 元数据数量庞大，造成性能瓶颈，建议合并或使用 CephFS |

---

| 文件类型 | 是否适合使用 Ceph | 理由 |
|----------|-------------------|------|
| 静态文件（如图片、音频、HTML、备份等） | ✅ 非常适合 | 读取频繁、写入少，适合对象存储特性，可高效缓存 |
| 动态文件（如频繁更新的数据库文件） | ❌ 不适合 | 高频更新会造成较高延迟，Ceph 不擅长高频小写入 |

南京全职公司电话面试（一个月两千多，没有住宿）：
1. 两个项目有没有遇到什么问题怎么解决的
- 第一个说了K8s没有部署成功
2. 除了protobuf优化节点数据序列化，还有没有什么方法
Cap’n Proto（Captain proto）
特点：比 Protobuf 更快、零拷贝、跨语言
优点：支持直接访问内存结构（不需要 decode）。高吞吐、低延迟

### 04-16
武汉一个小厂（最逆天的一集）
- 因为第一道题我写过了，然后又让我写一道，总共写了40分钟
- 写完算法就问我，两个项目的代码量是多少（第一个不知道，第二个五六百，他表示不相信共享屏幕给他看第二个项目），然后问我gin的controller用了哪些（我的项目确实没有用过，然后我也没有学过）
- 但是唯一就是提醒我第一个项目有很多东西要补回来吧
- 第一个项目将近4000行，第二个项目将近五百行

### 04-17
南京小厂二面（面的很爽的一集，问的基本都是golang的，基本都会）
1. git如何放弃当前的修改
git checkout\git restore\git reset
放弃当前的修改（还没add）\git add的反向操作\撤回提交（可以跨好几个提交）
2. git如何合并分支，使得冲突比较少
- 确保每个分支都基于最新 main
git rebase origin/main
- 设置合并顺序
先把冲突小的（改动少、独立的）合并；
再合并冲突大的；
如果 feature-b 依赖于 feature-a，就先合 a，再合 b。
- 按顺序 merge 到主分支
有冲突就手动解决，每次解决完都要 add + commit。

3. 项目的缓存击穿怎么实现？（略）
4. golang的协程相比较与线程的优点？

协程比较于线程：
- 轻量：1MB -> 2KB，轻轻松松创建成千上万个线程，这样也更好的利用系统的硬件资源
- 快速创建与销毁很快：协程的生命周期由Golang的调度器管理，并且线程的上下文切换也比较昂贵
- 无锁并发：协程之间的切换通常是无锁的，避免传统线程的锁竞争
- 更利于编写并发代码：Go的并发模型（channel+goroutine）编写的代码比传统的线程+锁的代码更加直观

5. 第一行写没有缓存的channel，第二行往里面写数据，能跑吗？
直接过不了编译，all goroutines are sleep deadlock

6. map可以存哪些数据类型
- key必须放可以比较的数据类型
- 除了切片、map、func，其他的类型基本都可以比较
7. 调算法的API一般需要什么
输入数据（如文本、图像、数值等）
输入参数（如超参数、配置等）
输出结果（如模型、预测值、处理结果等）
错误处理（如无效输入、算法错误等）
API 认证和授权（如 API 密钥、OAuth）
请求方式和格式（如 GET/POST，JSON 格式等）
性能需求和限制（如超时、数据大小限制等）
版本控制（如 API 版本号）

8. channel的底层有哪些数据结构
主要是就是三个环形队列和一个锁
- 一个缓冲区两个协程阻塞队列
- 一个是加锁的，防止读写时候出现并发问题

9. 函数退出前做一些处理，可以有什么方式
defer、panic、recover

10. 各个数据类型到底是分配到堆上还是栈上。变量、常量放哪？

| 类型/情况                          | 是否堆上分配                          |
|-----------------------------------|---------------------------------------|
| 基本类型的常量                    | ❌ 编译期内联，不分配                 |
| 基本类型的局部变量                | ✅/❌ 逃逸则在堆上，否则栈上           |
| 函数返回变量的地址                | ✅ 一定逃逸                           |
| 引用类型中的 make/map/slice       | ✅ 底层数据在堆上，头部逃逸则在堆上，否则在栈上 |
| 使用 new() 或取变量地址（&变量）  | ✅ 一般会导致逃逸，分配到堆上         |

- 准确地说，你并不需要知道。Golang 中的变量只要被引用就一直会存活，存储在堆上还是栈上由内部实现决定而和具体的语法没有关系。
- Golang 编译器会将函数的局部变量分配到函数栈帧上。然而，如果编译器不能确保变量在函数 return 之后不再被引用，编译器就会将变量分配到堆上。而且，如果一个局部变量非常大，那么它也应该被分配到堆上而不是栈上。
- 当前情况下，如果一个变量被取地址，那么它就有可能被分配到堆上,然而，还要对这些变量做逃逸分析，如果函数 return 之后，变量不再被引用，则将其分配到栈上。

11. 堆和栈的区别？

| 特性           | 栈（Stack）                               | 堆（Heap）                                 |
|----------------|--------------------------------------------|---------------------------------------------|
| 生命周期       | 随函数调用自动创建和销毁                  | 手动或由垃圾回收管理，生命周期长            |
| 分配速度       | ✅ 快（连续内存）                          | ❌ 慢（离散空间，碎片多，需 GC 管理）                 |
| 内存大小限制   | 通常较小（Go 会动态扩容）                 | 较大                                        |
| 分配方式       | 编译器直接分配（无 GC 干预）              | 通常由 runtime/GC 分配与释放                |
| 释放方式       | 函数返回后自动释放                        | 依赖垃圾回收机制                            |
| 逃逸分析       | 没有逃逸 ⇒ 栈分配                         | 有逃逸 ⇒ 堆分配                             |
| 地址是否可取   | ✅ 可取，但函数结束失效                   | ✅ 可取，地址长期有效                        |

12. 哈希冲突的解决方式
开放地址法、链地址法、再哈希、map
13. C/C++语言种数组指针+1代表什么
```C++
int arr[5] = {10, 20, 30, 40, 50};
int* p = arr;
std::cout << *(p) << std::endl;     // 输出 10
std::cout << *(p + 1) << std::endl; // 输出 20
std::cout << *(p + 2) << std::endl; // 输出 30
```
p + 1 实际上是 p 加上 sizeof(int) 个字节后的地址
所以 *(p + 1) 解引用后就是第二个元素：arr[1]

14. Restful API

内容：
- 资源（Resource）：被操作的对象，用 URL 表示。如 /users/1 表示 ID 为 1 的用户。
- 方法（Method）：使用 HTTP 的标准方法（GET、POST、PUT、DELETE 等）来操作资源。
- 表现层（Representation）：客户端与服务器通过 JSON、XML 等格式传输资源的表现。
- 无状态（Stateless）：每个请求都是独立的，服务端不会保存客户端状态。

设计规范：
- 使用 名词复数 表示资源：如 /users、/articles
- 避免动词（操作由 HTTP 方法表达）
- 子资源用嵌套表示：如 GET /users/1/orders 表示获取用户 1 的订单
- 使用状态码表示结果

### 4-21
**小红书**（问的都是没学过的）
1. linux启用一个进程，有哪些系统调用
- fork(): 创建当前进程的副本(子进程)
- exec()系列函数(execl, execle, execlp, execv, execvp, execvpe): 用新程序替换当前进程映像
- clone(): 类似于fork但更灵活，可以控制共享哪些资源

典型流程是先fork创建子进程，然后在子进程中调用exec加载新程序。

2. 查看ceph，IO负载、cpu负载
IO负载：
- 查看整体IO负载
ceph osd perf
- 查看每个OSD的IOPS和延迟
ceph osd df
- 更详细的性能数据
ceph osd pool stats

cpu负载：
- 查看monitor和OSD进程的CPU使用情况
top -p $(pgrep -d',' -f "ceph-(mon|osd)")
- 或者使用ceph自带的性能插件
ceph mgr module enable perf
ceph perf

3. 怎么接收用户（进程）信号，用context退出,通知协程退出底层（业务）是谁做的
协程需要不断的用select监听ctx.Done()，他其实就是一个channel, 如果在协程外使用cacel之后，这个channel会发送一个信号，协程收到这个信号之后才会主动退出
```Golang
package main

import (
	"context"
	"fmt"
	"os"
	"os/signal"
	"syscall"
	"time"
)

func main() {
	// 创建可取消的 context
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel() // 确保资源释放

	// 监听 SIGINT (Ctrl+C) 和 SIGTERM (kill)
	sigChan := make(chan os.Signal, 1)
	signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)

	// 启动工作协程
	go worker(ctx, "Worker 1")
	go worker(ctx, "Worker 2")

	// 阻塞等待信号
	sig := <-sigChan
	fmt.Printf("\nReceived signal: %v\n", sig)

	// 触发优雅退出：取消 context，通知所有协程
	cancel()

	// 等待协程退出（可选超时）
	time.Sleep(1 * time.Second) // 模拟清理耗时
	fmt.Println("All workers exited, shutting down.")
}

func worker(ctx context.Context, name string) {
	for {
		select {
		case <-ctx.Done():
			fmt.Printf("%s: Received shutdown signal, cleaning up...\n", name)
			time.Sleep(500 * time.Millisecond) // 模拟清理操作
			fmt.Printf("%s: Exited.\n", name)
			return
		default:
			fmt.Printf("%s: Working...\n", name)
			time.Sleep(1 * time.Second)
		}
	}
}
```

4. RGW一定会去查MON吗
- 在Ceph中，RGW操作不一定总是需要查询MON(Monitor)。
客户端缓存状态：如果客户端有最新的OSDMap缓存，可能不需要查询MON
操作类型：对于数据读取操作，通常只需要查询OSD，不需要MON
集群状态稳定性：在稳定状态下，大部分操作可以直接与OSD交互

- MON主要在以下情况被查询：
客户端首次连接集群
OSDMap版本过期或失效
​​异常场景（如OSD故障）可能触发MON查询以更新集群视图。
执行需要集群全局状态的操作(如创建池、修改CRUSH规则等)

5. 怎么解决缓存击穿（写代码）（略）

缓存击穿是因为Redis里的热点key突然失效导致大量请求打到数据库 给数据库很大压力

可以通过分布式锁和双重判定来解决

缓存穿透是Redis中本身就不存在的数据被大量请求 导致数据库压力很大 

可以通过布隆过滤器来做一次筛选 然后再使用分布式锁来解决

5. 一致性哈希怎么实现的(略)
6. CRUSH算法是怎么实现的？

- CRUSH 是一种 去中心化的、伪随机的、可控的映射算法，根据一定的规则 直接计算出数据对象应该存在哪些 OSD 上，而不是通过中心节点查表。
- 输入：
数据对象的 ID（如 object name 或 hash）
CRUSH Map（集群拓扑 + 权重 + 规则）
- 输出：
一组 OSD ID（表示将对象副本放在哪些 OSD 上）

- CRUSH Map（核心元数据结构）
包含以下信息：
OSD 列表：所有的存储节点
层次结构（Hierarchy）：比如 data center → rack → host → osd
权重：每个设备的相对容量
规则（ruleset）：比如“从不同的 rack 中选 3 个 OSD”
👉 这个 Map 是所有客户端都共享的副本，也就是说客户端自己就可以用它来算出数据存放在哪些 OSD。

- 选择流程（简化版）
定位桶（Bucket）：根据规则选定在哪个 rack/host 下选择
权重选择：优先选择空闲空间多的 OSD
避开失败节点：自动跳过 down 状态的 OSD
返回 OSD 列表：确定每个对象的副本放哪



**度小满**
1. map实现并发安全的方式有哪些
- Mutex、RWMutex
- sync.Map
- 用一些第三方库concurrent-map

2. map的底层怎么实现的（略）

3. MVCC中readView什么时候生成的
- ReadView 是在事务内第一次执行快照读（如 SELECT）时才生成的，用于确定当前事务能看到哪些版本的数据。
- 对于 当前读（加锁读，如 SELECT ... FOR UPDATE / UPDATE / DELETE），不使用 ReadView，而是直接读最新版本并加锁。

4. Golang GC的流程和劣势
-  GC 仍然存在开销（STW 或 CPU 消耗）
虽然 Go 1.5+ 已将 STW（Stop-The-World） 时间大大降低，但仍不可完全避免。
在高频率、大对象创建的系统中，GC 扫描、标记、清理依然会占用 CPU 时间。
- 内存占用偏高
Go 的 GC 倾向于 "以空间换时间"，为减少 GC 次数，往往不会急于释放内存。
程序空闲时也可能保持较高的 RSS（常驻内存集），不利于部署在内存敏感的容器中（如 k8s）。
-  分配成本较高（频繁GC会降低性能）
如果程序中频繁分配短生命周期的小对象，会增加 GC 频率，影响程序吞吐量。
使用过多小 slice、map 等，容易触发更多 GC。

对于低延迟系统（如游戏服务器、交易系统）可能导致响应抖动。

5. 算法：三个协程循环打印
三个协程都有一个for循环，三个chanel依次接受和发送

6. k8s的组件
一个Control plane，多个Node
用户通过 kubectl apply -f deployment.yaml 提交请求到 API Server。
API Server 将请求存储到 etcd，然后各个组件从 etcd 同步状态。
Controller Manager 看到 ReplicaSet 不足，创建新的 Pod。
Scheduler 监听到有新 Pod 无 Node，负责为其选择合适的节点，并更新绑定信息。
该 Node 上的 Kubelet 读取 Pod 信息，调用 Container Runtime (docker/container)创建容器。
Kubelet 监控 Pod 运行状态并持续汇报给 API Server。
kube-proxy 根据 Service 定义设置网络规则，保证服务可访问。
Controller Manager 定期检查实际状态和预期状态是否一致（比如副本数），发现偏差就通过 API Server 调整。

### 04-22
百度
1. 单体服务是怎么拆成微服务的，有哪些微服务
- account：处理用户注册登录、查询用户信息、文件列表、文件重命名等等
- apigw：鉴权、将用户的用户注册登录的HTTP请求转换为服务之间的RPC调用
- dpproxy：数据库的连接、orm做一些业务处理
- upload：文件（分块）上传
- download：文件下载
- transfer：文件上传迁移

2. Rabbitmq做了什么，发送和接受什么数据？routing key、交换机、queue之间是怎么协同工作的
- 发送和接受文件元数据，比如文件名、文件hash值、当前路径和目标路径等等
- 首先创建一个交换机和多个queue，比如说采用direct模式，每一个消息和queue都会指定一个routing key，当生产者发送消息到交换机，交换机收到消息之后会根据消息的routing key转发到对应同样routing key的queue中
3. kafaka和Rabbitmq对比（略）
4. JWT的双Token是怎么样刷新Token的，怎么防止Token泄露？短时效Token怎么进行刷新的
- 短时效的Token放在客户端的内存或者cookie（持久性比较强）中
- 长时效的Token放在服务端的redis中
每次登录的时候产生两个Token，然后转换页面的时候就会检查短时效的Token是否还在，如果还在就没事，如果不在就请求用服务端的长时效的Token刷新一个短时效的Token，同时长时效的Token也会刷新，如果长时效的Token也不存在了，那就需要重新登录
5. 文件的断点续传怎么实现？（略）
6. MYSQL主从复制怎么实现的，出现延迟怎么避免数据丢失
- 设置为半同步复制（semi-sync）：主库写数据时，必须等至少一个从库确认收到 binlog，才算 commit。
- ​GTID（全局事务标识）​​：从节点通过GTID定位未同步的事务，主节点恢复后继续同步。
7. 介绍仿做的GroupCache，为什么采用的protobuf实现的数据序列化，他有什么好处，有没有测试之前用json现在用protobuf的数据是什么样的

| 特性             | JSON                          | Protobuf                                 |
|------------------|-------------------------------|-------------------------------------------|
| 可读性           | 人类可读（纯文本）            | 二进制格式（不可读）                     |
| 编码/解码速度    | 较慢（需解析文本）            | 非常快（二进制解析）                     |
| 消息大小         | 较大（字段名+结构冗余）       | 非常小（使用 tag 编码，无字段名）        |
| 网络传输效率     | 较低                          | 高                                       |
| 使用便捷性       | 非常简单（无需额外工具）      | 较复杂（需编译器如 protoc）              |
| 多语言支持       | 广泛（几乎所有语言都支持）    | 广泛（支持 C++, Java, Python, Go 等）    |
| 调试方便性       | 直接查看内容                  | 需借助工具反序列化                       |


8. 算法：LRU（略）
9. 读golang程序
```Golang
slice := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9} // 初始切片
s1 := slice[2:5]
s2 := s1[2:6:7] // 第二次切片
// 第一次切片
s2 = append(s2, 10) // 第一次追加
s2 = append(s2, 11) // 第二次追加
s1[2] = 20
fmt.Println("slice:", slice, "len = ", len(slice), "cap = ", cap(slice))
fmt.Println("s1:", s1, "len = ", len(s1), "cap = ", cap(s1))
fmt.Println("s2:", s2, "len = ", len(s2), "cap = ", cap(s2))
```
主要注意s1和s2底层都是slice，不要把s2底层当作s1
```
slice: [0 1 2 3 4 5 6 7 8 9] len =  10 cap =  10
s1: [2 3 4] len =  3 cap =  8
s2: [4 5 6 7] len =  4 cap =  5
slice: [0 1 2 3 4 5 6 7 10 9] len =  10 cap =  10
s1: [2 3 4] len =  3 cap =  8
s2: [4 5 6 7 10] len =  5 cap =  5
slice: [0 1 2 3 4 5 6 7 10 9] len =  10 cap =  10
s1: [2 3 4] len =  3 cap =  8
s2: [4 5 6 7 10 11] len =  6 cap =  10
slice: [0 1 2 3 20 5 6 7 10 9] len =  10 cap =  10
s1: [2 3 20] len =  3 cap =  8
s2: [4 5 6 7 10 11] len =  6 cap =  10
```

### 04-24
1. 项目难点的介绍（防止缓存击穿的实现）
2. 项目适用于做什么（轻量级的缓存，不建议作为数据库，只取不存）
3. 有没有压测（没有）
单并发400RQS，100并发250RQS，系统吞吐量45KB/s
4. redis中RDB和AOF的区别（略）
5. 进程通信的方式，举一个例子(略)
6. http和https的区别？数据加密的流程？
- TCP连接建立
客户端（如浏览器）与服务器通过 TCP 三次握手建立连接。
- TLS 握手协商​​
>客户端发送支持的加密算法列表、随机数（Client Random）等信息。

>服务器选择加密算法（如 AES-256-GCM），返回随机数（Server Random）和​​数字证书​​（含公钥）。

>客户端验证证书有效性（如颁发机构、有效期、域名匹配）。
​​密钥交换​​。客户端用服务器公钥加密一个随机值（Pre-Master Secret），发送给服务器。

>​会话密钥生成​​：双方通过 Client Random、Server Random 和 Pre-Master Secret 生成相同的​​对称密钥​​（Session Key）。
- ​对称加密通信​​
后续所有数据传输均使用 ​​Session Key​​ 对称加密（如 AES），效率更高。
每次会话的密钥独立，避免长期密钥泄露风险。
- 数据完整性保护​​
使用 ​​MAC（消息认证码）​​ 或 ​​AEAD（如 GCM）​​ 确保数据未被篡改。
7. 一个数组找到前k个最小的（堆/桶排序）

### 04-25百度一面
1. 分布式云存储项目的设计?Mysql都存了什么数据?
2. gin用的什么中间件
3. Mysql主从复制原理
4. K8s和docker底层原理？docker通过什么访问各个容器？
- 最常用的访问容器的方式是通过端口映射将容器内部的服务暴露给宿主机，然后再通过宿主机的 IP 地址和映射的端口进行访问。
- 对于容器间的通信，则通常使用 Docker 网络。
5. Mysql索引？索引失效？
6. Mysql四种隔离级别？
7. 网站输入URL到展示页面流程？
8. HTTP和HTTPS的区别？
9. Golang的引用数据类型？
10. 数组和切片的区别？切片扩容？
11. linux创建多级文件夹？查看端口是否占用？占用系统CPU、内存情况？
12. 文件权限644？
13. 算法：最长无重复字符的子串的长度
14. 蚊香问题？

### 04-27
乐元素一面
1. ceph怎么部署的？数据量有多大？ceph中OSD崩了，自己手动怎么解决？
OSD崩了先定位问题，能重启重启，不能重启剔除坏OSD、换盘、重新部署OSD，数据恢复Ceph自己搞定。
2. protobuf底层原理？编译完是什么文件，以什么形式传输？
Protobuf本质上是把数据结构编译成代码，序列化成超小的二进制流(字节数组)，跨语言高效传输。
3. rabbitmq怎么用的？
4. redis持久化？
5. 项目有哪些服务？
6. k8s和docker底层原理？
7. GMP模型？协程和线程的区别？
8. channel的用法？怎么避免多个协程竞争往里面写数据？
用法：
- 生产者消费者模式（协程之间的通信）
- 用作信号控制最大并发数(多大的一个缓冲区)
- 事件通知（context.Done()）
避免竞争：
channel中自带有锁
9. 硬连接软连接
10. 算法：全排列

腾娱互动（以前问过的我就不记了，这次两个人面的，问了40分钟，口干舌燥，但是没有算法）
1. golang的内存管理
底层数据结构不会，但是说了内存泄露和内存逃逸
2. 上传的文件（分块）哈希校验失败，怎么办？
面试官说第一次失败再上传一定还会失败
3. redis解决缓存击穿的虚拟过期时间，数据没有真实过期，那内存很容易满怎么办？
4. 单体应用划分为微服务，抽取出来服务的原则有哪些？
- 业务边界清晰：基于领域驱动设计（DDD），按“限界上下文”划分，确保高内聚。
- 服务自治：每个服务独立部署、运行、拥有独立数据库。
- 接口清晰：服务间通过标准接口（如 REST/gRPC）通信，低耦合。
- 单一职责：每个服务聚焦一个具体功能，职责明确。
- 可扩展性：高访问频率或资源消耗大的模块优先独立，便于扩展。
- 变化率不同：频繁变化的模块应拆分出来，降低影响范围。
- 安全合规性：敏感数据处理功能单独拆分，提升安全性与合规性。

百度二面（完全问的项目）
1. 第一个项目设计的不合理，只是为了学技术
2. 第二个项目的一致性哈希动态扩缩容中的节点数据迁移没有实现
3. 啊啊啊啊啊啊啊啊啊啊啊
4. 操作系统启动的流程
5. 乱七八槽的各种网络协议，一个都没听过，开摆。
6. 高内聚低耦合的概念
7. 一个微服务的框架应有的东西（什么是好的微服务框架）
8. 防止缓存击穿的实现方式

**合合信息**

1. 容器化部署的优势
2. 写单元测试测试接口业务逻辑和性能
3. goroutine的channel使用起来的要注意的？channel的使用用途？
channel使用用途
- 生产者和消费者模式
- 事件通知
- 用作信号控制最大并发数
- 发送任务到协程池
4. sql语句起来很慢？
- 除了expalain和基础的sql优化还要去考虑表数据量太大，要分库分表
5. RAG
6. 多个生产者怎么保证channel只关闭一次
用主协程或者协调协程关闭，生产者本身不要去关闭
- waitgroup计数
- channel计数
7. 项目中有没有遇到goroutine竞争或者出现并发错误的情况
8. golang的优势
9. 什么时候创建组合索引

### 绿盟科技
1. 一行defer怎么实现函数启动做一些处理，结束时候做一些处理？比如计算函数运行的时间
defer里面的参数是当场注册的
```golang
defer func(start time.Time) { 
	fmt.Println("耗时:", time.Since(start)) 
}(time.Now())
```
2. k8s中一个pod宕掉了，怎么排查
- kubectl get pods: 查看 Pod 状态。
- kubectl describe pod <pod-name>: 查看 Pod 事件。
- kubectl logs <pod-name>: 查看容器日志。
- kubectl exec -it <pod-name> -- /bin/bash: 进入容器内部查看。
- kubectl get nodes 和 kubectl describe node <node-name>: 查看Node节点状态。
- kubectl top pod 和 kubectl top node: 查看资源使用情况。
- 检查 Pod YAML 文件中的 livenessProbe 和 readinessProbe 配置。
- 查看 Kubernetes 组件的日志 (根据你的部署方式)。
- 回顾最近的变更。
- 分析应用程序自身的错误。

3. 服务A接收服务B的数据，但是服务B的输出是时快时慢的，怎么解决对用户的反馈不会变差？（面试官提示用协程池）
​- ​协程池（Worker Pool）​​：固定数量的 Goroutine 处理任务，避免资源耗尽。
​- 异步非阻塞​​：服务A收到请求后立即返回"处理中"状态，实际任务交推送给消息队列然后由协程池处理。
- 结果回调​​：任务完成后通过 Webhook/长轮询通知用户。
4. 大模型应用输出的数据可能会泄露一些隐私，怎么解决，从后端开发的角度？

### 05-06
**腾娱互动二面**
就四个问题
1. 项目遇到的难点
k8s的部署和防止缓存击穿的实现
2. 一致性哈希怎么实现，他的缺点是什么
实现：
- 创建哈希环 (Hash Ring)
- 将节点映射到哈希环（可以采用虚拟节点） 
- 将键映射到哈希环:
- 查找负责的节点
- 添加节点
- 移除节点
缺点：
- 数据倾斜 (Data Skew)
- 新增或删除节点时的负载不均衡
- 实现复杂性增加
- 节点（真实节点和虚拟节点）数量难以确定

3. 为什么写这两个项目
4. 容器和镜像的区别
- 镜像 (Image) 就像一个安装包或者一个模版。
它包含了运行一个程序所需的所有东西，比如代码、库、系统工具等等。这个安装包是静态的，不会改变。你可以把镜像想象成制作蛋糕的食谱。
- 容器 (Container) 则是镜像运行起来的实例。
当你运行一个镜像，Docker 就会创建一个容器。容器是动态的、可以操作的。它就像你根据蛋糕食谱实际烤制出来的蛋糕。你可以同时运行多个基于同一个镜像的容器，就像你可以根据同一个食谱烤制多个蛋糕一样。
简单来说：
镜像是用来创建容器的蓝图。
容器是镜像运行时的状态。
5. 算法是LRU

### 05-08
**腾娱互动HR面**
1. 实习经历
2. 多人协作项目
3. 毕业期望工作地点

**波克城市一面**
1. cpu/内存的负载很高了怎么排查
2. k8s底层怎么通信？pod之间怎么通信？

3. OSD宕机数据怎么同步和恢复
当 Ceph OSD (Object Storage Daemon) 宕机时，数据的同步和恢复是一个自动化的过程，Ceph 的设计目标就是为了保证数据的冗余性和高可用性。以下是 OSD 宕机时数据同步和恢复的主要步骤和机制：

- 故障检测:
心跳机制 (Heartbeats): Ceph OSD 守护进程之间会定期发送心跳信息。Monitor 节点也会定期检查 OSD 的心跳。
故障报告: 如果一个 OSD 在一定时间内没有发送心跳，会被其他 OSD 和 Monitor 标记为 down。
Monitor 更新: Monitor 会更新集群的 OSD Map，标记宕机的 OSD 为失效状态.

- 数据恢复 (Recovery):
自动触发: 一旦 Monitor 确认 OSD 宕机，Ceph 会自动启动数据恢复过程。这个过程也被称为 self-healing。
Primary OSD 负责: 对于受影响的 Placement Groups (PGs)，其 Primary OSD 会协调数据的恢复。
寻找健康副本: Primary OSD 会与其他持有相同 PG 数据的健康 OSDs 通信，找到最新的数据副本。Ceph 的数据一致性是通过 Primary OSD 机制和 Paxos 算法在写入时保证的。
数据同步: 宕机 OSD 上缺失或过时的数据会从健康的副本 OSDs 同步过来。这个同步是基于 PG 级别的。
Recovery 优先级和限制: 为了避免恢复过程对正常 I/O 造成过大的影响，Ceph 会对恢复请求的数量、线程数和对象块大小进行限制。管理员也可以手动调整这些参数。

4. gin怎么写一个中间件，怎么使用？

```Golang
func MyMiddleware() gin.HandlerFunc {
	return func(c *gin.Context) {
		// 在处理请求之前执行的代码

		// 可以通过 c.Set() 在上下文中存储数据，供后续的 Handler 或中间件使用
		c.Set("exampleKey", "exampleValue")

		// 调用 c.Next() 将请求传递给下一个中间件或 Handler
		c.Next()

		// 在处理请求之后执行的代码
		statusCode := c.Writer.Status()
		println("Status Code:", statusCode)
	}
}
```

- MyMiddleware() 函数返回一个 gin.HandlerFunc。这是 Gin 中间件的标准形式。
- 返回的匿名函数接收 *gin.Context 作为参数，这个上下文对象包含了当前 HTTP 请求的所有信息（请求、响应、参数、头部等）。
- 请求前处理： 在 c.Next() 之前的代码会在处理请求之前执行。你可以在这里进行认证、授权、日志记录、数据预处理等操作。
- c.Next()：这个方法是中间件的关键。调用它会将请求传递给链中的下一个中间件。如果没有下一个中间件，请求会传递给最终的 Handler 函数。如果不调用 c.Next()，请求将被中断，后续的 Handler 和中间件将不会被执行。
- 请求后处理： 在 c.Next() 之后的代码会在 Handler 函数处理完请求之后执行。你可以在这里进行日志记录、响应后处理等操作。
- c.Set(key string, value interface{})：用于在 Gin 的上下文中存储键值对，这些数据可以在后续的 Handler 或其他中间件中通过 c.Get(key) 或 c.MustGet(key) 获取。
- c.Writer.Status()：可以获取响应的状态码。
5. gin在一个操作前做一个限流怎么做

```Golang
var redisClient *redis.Client
var rateLimitDuration = 1 * time.Second
var maxRequests = 5

func init() {
	redisClient = redis.NewClient(&redis.Options{
		Addr:     "localhost:6379", // 替换为你的 Redis 地址
		Password: "",             // 如果有密码
		DB:       0,              // 使用的数据库
	})
}

func RateLimitMiddleware() gin.HandlerFunc {
	return func(c *gin.Context) {
		ip := c.ClientIP()
		key := "rate_limit:" + ip

		count, err := redisClient.Incr(context.Background(), key).Result()
		if err != nil {
			c.AbortWithError(http.StatusInternalServerError, err)
			return
		}

		if count == 1 {
			redisClient.Expire(context.Background(), key, rateLimitDuration).Result()
		}

		if count > int64(maxRequests) {
			remaining := redisClient.TTL(context.Background(), key).Val()
			c.AbortWithStatusJSON(http.StatusTooManyRequests, gin.H{"error": "Too many requests", "retry_after": remaining.Seconds()})
			return
		}

		c.Next()
	}
}
```

这段 Go 代码是一个 Gin 中间件，用于限制每个客户端 IP 地址在一秒钟内的请求次数。它使用一个 map 记录每个 IP 的请求数，并用互斥锁保证并发安全。每当请求到达，计数增加，超过预设的 rateLimit (5次/秒) 就返回 "Too many requests" 错误。一个定时器在一秒后会将对应 IP 的计数减一，实现滑动窗口限流。

**合合信息二面**
1. 上传文件时候的安全性考量
我说了鉴权、文件hash校验，答：不够
2. 怎么用consul来进行服务注册与发现
3. 怎么防止多个goroutine对共享数据访问的冲突
4. 大模型的了解？RAG？RAG中R有什么方式？
5. 某个节点收到大量的请求怎么办
6. 二面就15分钟，几分钟后HR加微信告诉我薪资，然后说明天发offer

### 中控技术一面
sb面试官
算法：没有重复数字的最长子数组长度
- 这道题和力扣100里面有道题（无重复字符的最长子串）很像
我说我的思路是双指针+map，右指针不断右移并且存map数字计数，当前数字大于1，左指针右移，对应的map计数减一，每轮循环判断当前长度
- 他说我是看ai说的吗，思路驴头不对马嘴。我看你吗？那我问你一道算法就一种解法？最多我的思路效率不高呗，有毛病
- docker底层网络是什么
- golang的tag有什么用
- 

### 中控技术二面
虽然也没开摄像头，但是比上一个好说话多了
- 为什么做这两个项目
- 如果分块上传过程中文件（分块）没有了或者redis崩溃了怎么办
- docker层级部署，我问是不是RUN的中间镜像，答不是？难道是docker compose up？

### 乐元素二面
1. Golang实现一个大任务分为很多小任务，处理完小任务合并数据（比如小任务是乘法，然后加法合并）
拆开问：大任务怎么拆为小任务、怎么处理任务、怎么合并

