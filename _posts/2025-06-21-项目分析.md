1. ceph
块存储、文件存储、**对象存储（RadosGW）**
一个radosGW节点，三个Mon节点，三个OSD节点
- 上传流程：
👉 RGW（前台）接收你上传的文件。
👉 RGW 把 example.txt 切成几个“页”大小的小块（对象）。
👉 RGW 查询 MON（管理员）：我要存这些小块，去哪放？
👉 MON 看当前 OSD 状态，结合 CRUSH 算法，告诉 RGW：
小块1 放 OSD3、OSD5、OSD7（副本）
小块2 放 OSD2、OSD4、OSD6
👉 RGW 把小块分别发到这些 OSD 存起来。
👉 RGW 在 omap 中记录：你这个 example.txt 是由哪几个小块组成的，每块的名字、大小等。
✅ 上传完成！

- Rados
RADOS 是 Ceph 的核心，像是一个管理整个仓库的“大脑 + 工人队伍”。
RADOS = 智能仓库系统，负责把数据分片后分发、复制、存储、恢复。
你上传一个文件，它会帮你切片、分发、备份，自动搞定。
- OSD 就像是“仓库里的具体储物柜 + 工人”，负责具体存放和保护数据。
每个 OSD 管理着一块硬盘或存储空间。
一般你上传一个文件，它会存多个副本到不同的 OSD 上，确保一个坏了还能找回。
- MON 
就像是“仓库管理员”，他负责知道仓库里每一块地盘、每个储物柜的状态。
它记录哪些 OSD 还活着，哪些 OSD 坏了。
当客户端来上传数据时，它会告诉你“放哪儿最好”。
如果有机器死了，它会通知别的机器自动补救。 
- RGW
RGW 是“仓库前台 + 接待人员”，负责接收用户上传下载的请求。
支持 S3 接口（和 AWS S3 类似），开发者可以用标准工具或 SDK 访问。
它接收上传的文件，并传给 RADOS 处理存储。
- CRUSH
是一个“智能分发地图”，告诉系统每块数据该放哪。
它不像传统方式靠数据库记位置，而是用算法计算出每个数据该去哪些 OSD。
所以就算你集群扩容、机器变动，它也能自动重新分布数据，性能更高。

- ceph和腾讯云自带的都有分块上传api，但是腾讯云分块上传有接口，但是分块是限制在1MB。ceph可以实现并行上传，腾讯云好像只有串行。并行上传可以用waitgroup

2. 采用 consu进行服务发现，实现了私有云和公有云两种不同存储方式
- 私有云是ceph,可以部署在本地，公有云是阿里云和腾讯云（）
3. 上传文件的异步处理使用了消息队列RabbitMQ，邮箱验证码和文件分块信息采用redis进行保存
4. MySQL采用主从复制模式，读写分离，数据的写操作不会影响读操作
5. 系统功能类似网盘，可根据用户名及密码管理个人的云存储文件并分享，并且同时实现了文件秒传、分块上传以及断点续传和断点下载等功能
- 文件秒传：先获取文件的hash，与数据库中对比，如果有直接在数据库中逻辑复制
- 分块上传、断点续传、断点下载：
本地分块-->初始化信息存储到redis-->每一块串行依次传入到存储系统-->将块信息也传入到redis-->前端显示一个百分比进度条
暂停上传：分块上传-->定期检查文件上传信息-->是否是被暂停/被取消/全部上传完成
取消上传：根据redis中已经存在的块信息-->删除云储存系统里面的块和redis对应块信息-->删除redis初始化信息
恢复上传：并行的-->初始化分块信息时候可以把所有块信息也都写到redis中-->检查哪些块未上传接着上传
         串行的-->找到第一个未上传的-->传这个和之后的（串行时候前一个返回传输成功才添加redis信息）
7. 项目部署使用了 docker及 kubernetes 等容器化技术

### 利用 RabbitMQ 进行异步任务处理，加速文件上传流程
1. rabbitmq控制台：创建交换机（direct：相同的key才传递）和消息队列
2. config/rabbitmq.go:配置端口、是否开启异步模式、路由key、交换机名称、队列名称
3. 创建mq文件夹（define.go、producer.go、consumer.go）
    define.go：TransferData : 将要写到rabbitmq的数据的结构体（当前文件路径和目标文件路径）
    producer.go：初始化connection和channel，发布消息函数
    consumer.go：接收消息函数：循环读取channel中的数据
4. handler/upload.go：如果开启异步模式：发送消息
5. service/transfer/main.go && service/upload/main.go 
    transfer/main.go:设置回调函数（将文件存储到OSS中），开启消费函数（如果有消息在队列中就调用回调函数）

### go-micro
**流程**
1、定义接口
>基于proto协议
>使用protoc-gen-micro生成micro代码

2、实现接口
> 定义Handler

3、创建服务
> NewService服务
> Init初始化
> 挂载接口
> 运行

**Go-Micro层次**
1.  Service
2.  Client：发送RPC请求与广播信息
    Server：接受RPC请求与广播信息
3.  Broke：异步通信组件（rabbitmq）
    transport：同步通信组件（rpc）
    Codec：数据编码组件（protobuf）
    Registry：服务注册组件（consul、k8s）
    Selector：客户端均衡器：当多个实例提供相同服务时，决定负载均衡策略。（Traefik）

**Docker**
1. 通过Dockerfile定义容器环境，打包成镜像
2. 通过docker-compose.yml定义各应用服务
3. 用docker-compose up启动所有的容器
docker build、docker run
FROM COPY ADD CMD ENV EXPOSE
镜像 docker pull、docker image ls/rm 
容器 docker run/start/stop/restart、docker ps 

**k8s**
用了这个之后服务注册中心就从consul变成了k8s
Pod	最小部署单位，封装一个或多个容器
Node	运行 Pod 的物理/虚拟机
Cluster	一组 Node 组成的 Kubernetes 集群
写yaml文件
kubectl apply -f myapp.yaml

**反向代理负载均衡traefik**
- 相比于nginx，它能够自动发现后端服务，无需手动配置代理规则。
- Frontend（Routers路由）：处理用户请求，定义路由规则（如域名、路径等）。负责接收和处理外部请求，然后决定将请求转发到哪个Backend。
- Backend（Services服务）：真正的服务，Frontend会把请求转发到Backend。是一个真正的应用（Web服务、Pod、Docker容器）


**HTTP和RPC**
- HTTP是一个应用层协议，RPC是远程过程调用，只是一种函数（或方法）调用方式，与之对应的是本地调用，所谓的RPC协议其实只是基于TCP、UDP甚至是HTTP2改造之后的协议
- HTTP有很多适应浏览器的冗余字段，这些事内部服务用不到的，RPC可以摒弃很多HTTP Header中的字段（比如浏览器的各种行为）
- HTTP数据格式是JSON/XML（文本格式），但是RPC是Protobuf、Thrift（二进制格式），后者传输效率更高
- HTTP更适用于Web应用、前后端交互，而RPC更适用于微服务、分布式系内部通信。

RPC比HTTP出现的早，主要就是为了解决远程函数调用的问题。
一个单体服务内部的各个模块之间可以直接用本地函数（方法）调用，但是一个分布式微服务的系统内部各个模块的都是独立的服务，他们可能存储在不同的主机或者不同的容器中，那么他们就只能用远程函数（方法）调用

# 技术栈面试问题及回答示例

下面整理了在该项目中各个技术栈的详细问题和回答示例，帮助您更全面地展示对项目技术体系的理解和掌握情况。

---

## 1. Gin

### 问题 1：为什么选择 Gin 作为 Web 框架？
**回答示例：**  
“我选择 Gin 主要是因为它的高性能和轻量级特点。Gin 内置了高效的路由匹配和中间件支持，能够满足我们对 API 网关和微服务的高并发需求。此外，Gin 的错误处理和日志记录功能也让调试和维护变得更简单。”

### 问题 2：在 Gin 中如何处理静态文件？
**回答示例：**  
“在项目中，我们通过 `gin-contrib/static` 处理静态文件，但为了更好地管理部署，使用了 `go-bindata` 将静态文件嵌入到二进制中。这样可以避免依赖外部文件系统，确保部署时环境的一致性，并简化运维管理。”

---

## 2. Go-Micro

### 问题 1：为什么选择 Go-Micro 构建微服务？
**回答示例：**  
“Go-Micro 提供了一个完备的微服务生态系统，包括服务注册、负载均衡、RPC 调用、异步消息等内置支持，能够大大简化微服务的开发和维护。它与 Consul、Traefik 等组件的集成也十分紧密，使得整个服务网格更加稳定和高效。”

### 问题 2：Go-Micro 如何实现高效的 RPC 通信？
**回答示例：**  
“Go-Micro 封装了底层 RPC 调用细节，利用 ProtoBuf 进行数据编码，实现二进制传输，从而显著减少数据包大小和网络开销。同时，通过 transport 模块可以灵活切换不同的传输协议，如 gRPC，这为系统的高并发调用提供了保障。”

---

## 3. MySQL

### 问题 1：在项目中如何保证 MySQL 在高并发下的数据一致性和性能？
**回答示例：**  
“我们采用了主从复制与读写分离的架构。主库处理写操作，从库负责查询，既保证了数据的一致性，又有效分担了查询压力。此外，必要时可以使用分库分表来进一步优化性能。”

### 问题 2：遇到数据库瓶颈时，您如何应对？
**回答示例：**  
“除了读写分离外，我们还结合 Redis 缓存热点数据，减少对数据库的直接访问。同时，通过慢查询日志监控数据库性能，定期进行索引优化和 SQL 调优，以保持数据库高效运行。”

---

## 4. Redis

### 问题 1：Redis 在项目中的主要用途有哪些？
**回答示例：**  
“在项目中，Redis 主要用于存储文件分块信息，以支持断点续传，同时存储邮箱验证码和用户会话信息，以提升注册登录的响应速度。通过 Redis 高速的内存存储，我们能够在高并发环境下迅速返回结果，改善用户体验。”

### 问题 2：如何保证 Redis 数据的稳定性和可靠性？
**回答示例：**  
“我们采用了 Redis 持久化机制（RDB/AOF）来防止数据丢失，并设置了主从复制以实现高可用性。同时，通过监控 Redis 的内存和性能指标，及时调整配置参数，确保系统在高负载下依然稳定运行。”

---

## 5. Ceph

### 问题 1：为什么选择 Ceph 作为私有云存储解决方案？
**回答示例：**  
“Ceph 提供分布式存储、自动故障转移以及横向扩展能力，非常适合处理海量数据存储的需求。它能实现高可用性和数据冗余，与公有云存储（如阿里 OSS、腾讯 COS）相结合，实现灵活的存储策略，根据不同业务场景动态切换存储后端。”

### 问题 2：如何实现私有云与公有云存储的动态切换？
**回答示例：**  
“在设计时，我们抽象出统一的存储接口，通过配置中心控制选择存储后端。当系统检测到私有云资源不足或需要扩展时，可以动态切换到公有云存储，从而保证数据存储的连续性和高可用性。”

---

## 6. Consul

### 问题 1：Consul 在服务注册与发现中的作用是什么？
**回答示例：**  
“Consul 作为注册中心，自动注册所有微服务实例，并定期进行健康检查。这样，当客户端调用服务时，能够通过 Consul 动态获取最新的实例列表，从而实现高效的服务发现和故障切换。”

### 问题 2：如何与 Go-Micro 集成使用 Consul？
**回答示例：**  
“我们在 Go-Micro 的配置中指定 Consul 作为服务注册中心，这样每个服务在启动时都会自动注册到 Consul，同时客户端在调用时通过 Consul 获取服务列表，实现无缝对接和负载均衡。”

---

## 7. Traefik

### 问题 1：Traefik 如何实现负载均衡和动态路由？
**回答示例：**  
“Traefik 通过监控 Consul 或 Kubernetes 中的服务变更，自动配置路由规则，并基于内置的负载均衡算法（如轮询、最少连接）将请求分发到多个实例。这样可以有效分散流量，提高系统稳定性。”

### 问题 2：与传统负载均衡器相比，Traefik 有什么优势？
**回答示例：**  
“Traefik 支持自动发现和动态配置，无需手动修改配置文件。它还内置了对 HTTPS 证书的管理功能，可以自动申请和续期 SSL 证书，降低运维复杂度，同时支持多种协议和中间件，适应微服务环境的多变需求。”

---

## 8. RabbitMQ

### 问题 1：RabbitMQ 在项目中如何加速文件上传流程？
**回答示例：**  
“文件上传过程中，部分耗时操作（如分块上传校验和数据处理）通过 RabbitMQ 异步处理，减小主流程响应时间。消息队列将上传任务拆分为多个子任务并行处理，从而提升整体上传效率和系统吞吐量。”

### 问题 2：如何确保 RabbitMQ 的消息可靠性？
**回答示例：**  
“我们配置了消息确认机制和持久化策略，确保消息在传输过程中不会丢失。同时，通过合理设计队列长度和监控指标，及时处理队列积压和异常情况，保证系统稳定运行。”

---

## 9. ProtoBuf

### 问题 1：为什么选择 ProtoBuf 进行数据编码？
**回答示例：**  
“ProtoBuf 是一种高效的二进制序列化协议，与 JSON 相比，它具有更小的数据包体积和更快的解析速度，特别适用于高并发的 RPC 通信。其强类型机制还可以在编译期发现数据不一致问题，降低运行时错误的风险。”

### 问题 2：在 Go-Micro 中如何使用 ProtoBuf？
**回答示例：**  
“在 Go-Micro 中，我们定义了 .proto 文件，通过 protoc 工具生成对应的 Go 代码，然后在服务间的 RPC 调用中使用这些生成的类型进行数据传输，实现高效、可靠的通信。”

---

## 10. JWT 双 Token 刷新策略

### 问题 1：双 Token 刷新策略如何提升系统安全性？
**回答示例：**  
“双 Token 策略中，我们采用短时 Token 用于频繁访问，长时 Token 用于刷新短时 Token。这样既降低了单个 Token 被泄露后的风险，又减少了频繁认证对系统性能的影响，确保 API 请求的安全性。”

### 问题 2：如何处理 Token 的刷新和失效？
**回答示例：**  
“系统在每次验证时会检查 Token 的有效期，若短时 Token即将过期，则允许使用长时 Token刷新新的短时 Token。刷新成功后，旧的 Token 立即失效，从而避免并发认证带来的安全风险。”

---

## 11. Docker & Kubernetes

### 问题 1：为什么选择 Docker 和 Kubernetes 部署项目？
**回答示例：**  
“Docker 能够将各个微服务封装成独立的容器，确保环境一致性和快速部署；Kubernetes 提供自动扩缩容、服务发现和故障自愈等能力，使得整个微服务系统更易于管理和维护，提升了系统的可移植性和部署效率。”

### 问题 2：在 Kubernetes 中如何管理服务的扩展性？
**回答示例：**  
“Kubernetes 通过 Deployment 对象管理服务副本，结合 Horizontal Pod Autoscaler 实现自动扩容。当监控指标（如 CPU 或内存使用率）达到预设阈值时，Kubernetes 会自动增加或减少 Pod 数量，从而保证系统始终处于最佳运行状态。”

---

以上问题和回答示例覆盖了项目中使用的主要技术栈和核心实现细节，能够帮助您在面试中充分展示自己对系统架构和关键技术的深入理解。
